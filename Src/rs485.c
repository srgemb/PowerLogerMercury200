
#include <stdint.h>
#include <stdbool.h>
#include <string.h>

#include "rs485.h"
#include "param.h"
#include "events.h"
#include "modbus.h"
#include "main.h"

#include "cmsis_os.h"
#include "stm32f1xx_hal.h"

//****************************************************************************************************************
// Локальные константы
//****************************************************************************************************************
#define RX_BUFFER_SIZE      255     //размер приемного буфера

#define THREAD_RECV         0       //режим приема запросов по шине RS485
#define THREAD_SEND         1       //режим отправки ответов по шине RS485

//****************************************************************************************************************
// Внешние переменные
//****************************************************************************************************************
extern UART_HandleTypeDef huart1;

//****************************************************************************************************************
// Локальные переменные
//****************************************************************************************************************
static uint8_t cnt_timer = 0, mode = THREAD_RECV; 
static uint8_t rx_buffer[RX_BUFFER_SIZE];
osThreadId tid_Thread485Recv, tid_Thread485Send;

//****************************************************************************************************************
// Локальные прототипы функций
//****************************************************************************************************************
static uint8_t RecvCnt( void );
static void ClearRecvBuff( void );

static void Thread485Recv( void const *arg );
static void Thread485Send( void const *arg );

osThreadDef( Thread485Recv, osPriorityNormal, 1, 0 );
osThreadDef( Thread485Send, osPriorityNormal, 1, 0 );

//*****************************************************************************************
// Инициализация интерфейса RS485
//*****************************************************************************************
void RS485Init( void ) {

    memset( rx_buffer, 0x00, sizeof( rx_buffer ) );
    
    tid_Thread485Recv = osThreadCreate( osThread( Thread485Recv ), NULL );
    tid_Thread485Send = osThreadCreate( osThread( Thread485Send ), NULL );

    HAL_GPIO_WritePin( RS485_CTRL_GPIO_Port, RS485_CTRL_Pin, GPIO_PIN_RESET );
    HAL_UART_Receive_IT( &huart1, rx_buffer, sizeof( rx_buffer ) );
 }

//**********************************************************************************
// Кол-во принятых байт по UART1
//**********************************************************************************
static uint8_t RecvCnt( void ) {

    return huart1.pRxBuffPtr - (uint8_t *)rx_buffer;
 }

//**********************************************************************************
// Чистим приемный буфер
//**********************************************************************************
static void ClearRecvBuff( void ) {

    memset( rx_buffer, 0x00, sizeof( rx_buffer ) );
    huart1.RxXferCount = sizeof( rx_buffer );
    huart1.pRxBuffPtr = (uint8_t*)rx_buffer;
 }

//*****************************************************************************************
// Поток ослеживает прием запроса по RS485
//*****************************************************************************************
static void Thread485Recv( void const *arg ) {

    uint8_t rc;
    
    while ( true ) {
        osDelay( 1 );
        if ( mode == THREAD_SEND )
            continue;
        rc = RecvCnt();
        if ( rc && cnt_timer > 1 ) {
            //проверка запроса, формирование ответа
            CheckFrame( rx_buffer, rc ); 
            //независимо от результата проверки текущего запроса 
            //очистим буфер для приема следующего запроса
            ClearRecvBuff();
           }
                
       }
 }

//*****************************************************************************************
// Поток контролирует завершение передачи ответа по RS485
//*****************************************************************************************
static void Thread485Send( void const *arg ) {

    while ( true ) {
        if ( mode == THREAD_RECV )
            continue;
        //проверяем завершение отправки пакета
        if ( !huart1.TxXferCount && huart1.gState == HAL_UART_STATE_READY ) {
            HAL_GPIO_WritePin( RS485_CTRL_GPIO_Port, RS485_CTRL_Pin, GPIO_PIN_RESET );
            mode = THREAD_RECV;
           }
       }
 }

//*****************************************************************************************
// Иницирует передачу блока данных в последовательный порт
// char *data       - адрес исходного буфера с данными 
// uint8_t len_data - размер передаваемого блока
//*****************************************************************************************
void RS485Send( uint8_t *data, uint8_t len_data ) {

    cnt_timer = 0; //перезапуск таймера паузы
    HAL_GPIO_WritePin( RS485_CTRL_GPIO_Port, RS485_CTRL_Pin, GPIO_PIN_SET );
    mode = THREAD_SEND;
    HAL_UART_Transmit_IT( &huart1, data, len_data );
 } 

//*****************************************************************************************
// Инкремент таймера для определения паузы на шине MODBUS
// Вызов из TIM1_UP_IRQHandler() stm32f1xx_it.c
// Параметры Timer1: F = 500 Hz; T = 2 ms; t = 1 ms
//*****************************************************************************************
void RS485Timer( void ) {

    if ( cnt_timer < 255 )
        cnt_timer++;
 }
 
//****************************************************************************************************************
// Перезапуск таймера.
// Проверка на переполнение буфера данных. Вызывается при приеме и передаче.
// Вызов из USART1_IRQHandler() stm32f1xx_it.c
//****************************************************************************************************************
void RS485Irq( void ) {

    cnt_timer = 0; //перезапуск таймера паузы
    if ( mode == THREAD_SEND )
        return; //во время передачи игнорируем обработку
    //проверка на переполнение буфера
    if ( RecvCnt() > sizeof( rx_buffer ) - 1 )
        ClearRecvBuff();
 }
